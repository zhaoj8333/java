package mem;

public class MethodCall
{
    public static void main(String[] args)
    {
        
    }

    /**
     * 方法调用：
     *
     * 方法调用不同于方法执行，方法调用是为了确定方法的版本，即调用哪个方法，不涉及方法内部执行过程。
     * class文件的编译过程不包含传统的编译过程的链接步骤，一切方法在class文件中只是符号引用，而不是方法
     * 的入口内存地址，该特性给了java强大的动态扩展能力。
     * 但是，该特性使得运行期间才能确定目标方法的直接饮用。
     *
     * 解析：
     * 
     * 方法调用的目标方法在class文件中都是一个常量池中的符号引用，在类加载解析阶段，会将其中一部分符号
     * 引用转化为直接引用。
     * 这种解析能成立的前提是方法在程序真正运行之前就有一个确定的调用版本，且该方法的调用版本在运行期间不可改变。
     * 
     * ->调用目标在代码写好，编译器进行编译时就已经确定了下来，这类方法调用称为 解析。
     * [编译器可知，运行期不改变]
     * 主要包括：静态方法(与类型直接关联) 和 私有方法(外部不可访问) ,这两者决定了不可能通过继承或别的
     *      方式重写其版本。因此适合在类加载阶段解析。
     *
     * 方法调用字节码指令：
     *
     * invokestatic: 调用静态方法
     * invokespecial: 调用实例构造器方法、私有方法和父类方法
     *
     * invokevirtual: 调用所有虚方法
     * invokeinterface: 调用接口方法，会在运行时再确定一个实现此接口的对象
     * invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
     * 
     * invokespecial,invokestatic都可以在解析阶段确定唯一的调用版本，加载时就会把符号引用解析为直接引用
     * 这些方法称为非虚方法，其他方法称为虚方法
     *
     * final关键字修饰的方法是非虚方法,但final方法是使用invokevirtual调用的，但是本身无法被覆盖，java语言
     * 规范中明确说明final方法时非虚方法。
     *
     * 解析调用：是一个静态过程，编译期间就能完全确定，不会延迟到运行期间再去完成。
     * 分派调用：则可以使静态，也可能是动态的。
     *
     */
    
    /**
     * 分派：
     *
     * 静态分派：
     * Static Dispatch
     *
     *
     */
    
}
