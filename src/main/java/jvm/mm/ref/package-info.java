/*
    Soft: 软引用, 内存不够时一定会被GC,长期不用也会被gc
    Weak: 一定会被gc, 当被mark为dead时, 会在ReferenceQueue中通知
    Phantom: 本来就没有引用, 当从jvm堆中释放时会通知

    GC时机:
        Scavenge GC(Minor GC):
            触发时机: 新对象生成时, Eden空间满了
            理论上Eden大多数对象会在minor gc回收, 复制算法的执行效率会很高, 执行时间偏短
        Full GC:
            对整个jvm进行整理, 包括young, old 和perm
            触发时机: old满了, perm满了, system.gc()
            效率低, 尽量减少

     jvm提供多种垃圾回收器,需要根据具体应用采取不同的回收器
     没有万能的垃圾回收器,每种垃圾回收器都有自己的适用场景

     垃圾收集器的并发/并行
        并行: 多个垃圾收集器同时工作, 但是用户线程处于等待状态
        并发: 收集器与用户线程同时工作
            并发不代表解决了gc停顿问题, 关键步骤还是要停顿, 如在标记时, 清除时可以并发执行

     -----新生代收集器-----------------------------------------------------------------------
     Serial收集器:
        单线程收集器,收集时会暂停所有工作线程,
        使用复制收集算法,
        新生代和老年代都可以使用, 新生代使用复制算法; 老年代使用mark-compact算法
        为java Client模式下的默认收集器

     ParNew收集器:
        Serial的多线程版本
        java server模式下的新生代收集器
        只能用于多CPU环境下, 效率才会比serial收集器高

     Parallel Scavenge收集器
        多线程收集器,
        使用复制算法
        对象分配与回收策略与ParNew不同, 以吞吐量最大化(GC时间最小)为目标的实现,
        允许以较长的STW换取总吞吐量最大化
     -----老年代收集器-----------------------------------------------------------------------
     Serial Old老年代的serial

     Parallel Old:
        老年代 吞吐量优先 收集器
        使用多线程与标记-整理算法

     CMS收集器:
        以最短停顿时间为目标
        尽可能降低GC停顿时间, 适合web应用, 一般结合parnew使用



 */
package jvm.mm.ref;