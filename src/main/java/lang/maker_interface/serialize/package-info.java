package lang.maker_interface.serialize;

/*
序列化协议属于TCP/IP协议应用层的部分

序列化：
    将数据结构或对象转化成二进制的过程

反序列化：
    将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程

数据结构与对象：

二进制串：序列化生成的二进制串指的是内存中的一块数据，java中二进制串不是String，String在java中是特殊对象，对于跨语言之间的通讯肯定不能是某种语言的特殊数据类型
    二进制串在java中指的是byte[]

序列化协议设计：
    通用性：跨平台，跨语言
    强健性：协议从指定到实施需要漫长的测试；如果所支持的平台或语言难以调和时可能在支持更多平台或放弃某种特性之间做出权衡
    可调试性：
    性能：
    可扩展性：
    安全性：

序列化和反序列化组件：
    IDL（Interface Description Language）文件：参与通讯各方需要对通信内容做出约定，该约定与具体语言，平台无关，该语言称为接口描述语言，采用IDL撰写的协议约定称为IDL文件
    IDL compiler：该编译器将IDL文件转换成各语言对应的动态库
    Stub/Skeleton Lib：负责序列化和反序列化的工作代码。
        Stub：部署在客户端的代码，负责接收应用层参数，将其序列化通过底层协议发送到服务端；同时接收服务端序列化后的结果数据，反序列化后交给客户端应用；
        Skeleton：部署在服务端，与Stub相反
    Client/Server：应用层程序代码，面对的是将IDL所生存的特定语言的class或struct
    底层协议和互联网：网络协议层

序列化与数据库访问：
    序列化         数据库             说明
    IDL           DDL               用于建表或模型的语言
    DL file       DB schema         表创建文件或模型文件
    Stub/Skeleton O/R mapping       将class和table的映射

序列化协议：
    COM：用于windows平台，没有真正跨平台
    CORBA:
    XML&SOAP：
        XML：本质是一种描述性语言，格式有DTD,XSD，是一种肉眼可读的描述性语言，广泛应用于配置文件
        SOAP：一种基于xml序列化和反序列化协议的结构化消息传递协议，基于soap的解决方案成为web service,支持多种传输协议，不过一般基于xml+http，其描述语言为WSDL,基于xml的无需IDL文件和第三方编译器

        SOAP人眼可读，但是空间开销较大，对于小数据量传输和实时性要求较低是一个好的选择，XML的序列化和反序列化空间和时间开销都较大

    JSON:
        其本质是采用associative array的概念，人眼可读，相对xml简洁，js天生支持，与xml相比解析较快，扩展性较好
        采用json进行序列化的开销较大，对于大数据或持久化开销较大，没有可用的IDL降低了参与方的约束，实际操作中只能用文档方式来约定，由于json在一些语言中的序列化和反序列化需要反射机制，所以如果性能要求在ms级别，不建议采用

    Thrift:
        Thrift不仅仅是序列化协议，而且也是RPC框架，相对于json和xml，thrift在空间和解析性能上有很大提升；
        但是thrift的序列化被嵌入到thrift里面，thrift本身没有透露出序列化和反序列化接口，导致很难和其他传输协议公用。
        对于高性能，分布式的rpc，thrift是一个优秀的解决方案,适合公司内部的SOA的标准RPC框架

    Protobuf:
        标准的IDL和IDL编译器，对工程师友好
        序列化数据非常简洁，紧凑，与xml相比，序列化后的数据量很少
        解析速度快，比xml块20-100倍
        提供了友好的动态库

        protobuf仅支持java，c++，python，支持的数据类型相对较少，不支持常量类型

    Avro：
        属于apache子项目，提供json格式和binary格式
 */